#include <iostream>

void lambda_intro()
{
	auto just_one([]() { return 1; });
	auto just_two([] { return 2; });
	std::cout << just_one() << ", " << just_two() << '\n';
	// ----------------------------------------
	auto plus([](auto l, auto r) { return l + r; });
	std::cout << plus(1, 2) << '\n';
	std::cout << plus(std::string{ "a" }, "b") << '\n';
	// ----------------------------------------
	std::cout
		<< [](auto l, auto r) { return l + r; }(1, 2)
		<< '\n';
	// ----------------------------------------
	auto counter(
		[count = 0]() mutable { return ++count; }
	);
	for (size_t i{ 0 }; i < 5; ++i) {
		std::cout << counter() << ", ";
	}
	std::cout << '\n';
	// ----------------------------------------
	int a{ 0 };
	auto incrementer([&a] { ++a; });
	incrementer();
	incrementer();
	incrementer();
	std::cout
		<< "Value of 'a' after 3 incrementer() calls: "
		<< a << '\n';
	// ----------------------------------------
	auto plus_ten([=](int x) { return plus(10, x); });
	std::cout << plus_ten(5) << '\n';
	//common syntax
	/*
	[список захвата] (параметры)
		mutable      (optional)
		constexpr    (optional)
		exeptionattr (optional)
		-> возвращаемый тип (optional)
		{
			тело
		}
	Список захвата:
	[=] - все по значению
	[&] - все по ссылке
	[a, &b] - копируем а и берем ссылку на b
	[&, a] - копируем а и берем ссылки на все остальное
	[=, &b, i{22}, this] - ссылка на b, 
	                       копируем this(написать &this - нельзя, *this - можно), 
						   инициализируем новую переменную i значением 22,
	                       все остальное копируем.
	mutable - Если объект функции должен иметь возможность модифицировать 
	          получаемые им переменные путем копирования ([=]), 
			  то его следует определить как mutable. 
			  Это же касается вызова неконстантных методов захваченных объектов.

	constexpr - Если мы не указываем явно, 
	            что лямбда-выражения являются constexpr, 
				но эти выражения соответствуют всем требуемым критериям, 
				то они все равно будут считаться constexpr, 
				только неявно. Если нужно, чтобы лямбда-выражение было constexpr, 
				то лучше явно задавать его таковым, 
				поскольку иначе в случае наших неверных действий 
				компилятор начнет генерировать ошибки
	
	exeptionattr - Здесь определяется, может ли объект функции генерировать исключения, 
	               если при вызове столкнется с ошибкой.

	return type - При необходимости иметь полный контроль над возвращаемым типом, 
	              вероятно, не нужно, чтобы компилятор определял его автоматически. 
				  В таких случаях можно просто использовать конструкцию [] () -> Foo {}, 
				  которая укажет компилятору, что мы всегда будем возвращать объекты типа Foo.
	
	*/

}